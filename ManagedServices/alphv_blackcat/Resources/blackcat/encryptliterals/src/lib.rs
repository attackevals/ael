use proc_macro::TokenStream;
use proc_macro2::Literal;
use quote::quote;
use base64::{engine::general_purpose, Engine as _};
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use syn::{parse_macro_input, LitStr, Token, parse::{Parse, ParseStream}};

// Random seed for XOR key
lazy_static::lazy_static! {
    static ref RAND_SEED: [u8; 64] = {
        let mut seed = [0u8; 64];
        let mut rng = ChaCha20Rng::from_entropy();
        ChaCha20Rng::fill_bytes(&mut rng, &mut seed);
        seed
    };
}

struct EncryptCfgMacroInput {
    cfg_path: LitStr,
    _comma: Token![,],
    enc_key: LitStr,
}

impl Parse for EncryptCfgMacroInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(Self {
            cfg_path: input.parse()?,
            _comma: input.parse()?,
            enc_key: input.parse()?,
        })
    }
}

fn xor_crypt(input: Vec<u8>, key: &[u8]) -> Vec<u8> {
    let mut key_iter = key.iter().cycle();
    return input.into_iter().map(|x| x ^ key_iter.next().unwrap()).collect()
}

fn get_xor_key() -> Vec<u8> {
    // Encrypted using random key generated by /dev/urandom
    xor_crypt(RAND_SEED.to_vec(), b"c27abfd9ea8cf0c81d07b6f9ae9d2a8e")
}

/// AES-CTR-128 encrypt and then base64-encode the contents of the configuration path file with the provided key
/// Note: publicly released version will not encrypt the configuration contents - it will only base64-encode.
#[proc_macro]
pub fn encrypt_cfg(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as EncryptCfgMacroInput);
    let cfg_path = String::from((&parsed.cfg_path).value());
    let key_str = String::from((&parsed.enc_key).value());
    let key_bytes = key_str.into_bytes();
    if key_bytes.len() != 16 {
        panic!("Expected key length of 16, got {}", key_bytes.len());
    }
    let mut key = [0u8; 16];
    for i in 0..16 {
        key[i] = key_bytes[i];
    }
    let cfg_string = match std::fs::read_to_string(cfg_path.clone()) {
        Ok(s) => s,
        Err(e) => panic!("Failed to read from config file {}: {}", cfg_path, e),
    };
    let input = cfg_string.into_bytes();
    let encoded = general_purpose::STANDARD.encode(&input);
    quote!{ #encoded }.into()
}

/// Sets the XOR encryption key for encrypting string literals in a esl! macro. 
/// The key seed will be randomly generated each time during compilation.
/// The key seed will be XOR-encrypted to generate the actual XOR key.
/// Adapted from litcrypt crate: https://github.com/anvie/litcrypt.rs
#[proc_macro]
pub fn setup_string_literal_encryption(_input: TokenStream) -> TokenStream {
    // Grab XOR key
    let xor_key = get_xor_key();
    let enc_key_literal = Literal::byte_string(&xor_key);

    quote! {
        pub mod string_lit_encrypt {
            pub static STRING_LITERAL_ENC_KEY: &'static [u8] = #enc_key_literal;

            pub fn decrypt(input: &[u8], key: &[u8]) -> String {
                let mut key_iter = key.iter().cycle();
                let decrypted = input.into_iter().map(|x| x ^ key_iter.next().unwrap()).collect();
                match std::string::String::from_utf8(decrypted) {
                    Ok(s) => s,
                    Err(_) => String::from("[esl unknown]")
                }
            }
        }
    }.into()
}

/// Encrypt the string literal using the key from setup_string_literal_encryption, 
/// and replace with a function call to decrypt the ciphertext during runtime.
/// Adapted from litcrypt crate: https://github.com/anvie/litcrypt.rs
#[proc_macro]
pub fn esl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LitStr);
    let string_to_encrypt = input.value();
    let encrypted = xor_crypt(string_to_encrypt.into_bytes(), &get_xor_key());
    let encrypted_literal = Literal::byte_string(&encrypted);

    // Replace with decrypt routine
    quote! {
        crate::string_lit_encrypt::decrypt(#encrypted_literal, crate::string_lit_encrypt::STRING_LITERAL_ENC_KEY)
    }.into()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xor_crypt() {
        let input:Vec<u8> = [
            0x2du8,0x0du8,0x11u8,0x01u8,0x08u8,0x46u8,0x0eu8,0x40u8,0x42u8,0x47u8,0x5eu8,0x14u8,0x51u8,0x0eu8,
            0x0eu8,0x0cu8,0x16u8,0x45u8,0x15u8,0x0eu8,0x44u8,0x11u8,0x53u8,0x5eu8,0x51u8,0x41u8,0x4du8,0x42u8,
            0x00u8,0x0bu8,0x0bu8,0x15u8,0x02u8,0x53u8,0x45u8,0x57u8,0x47u8,0x41u8,0x47u8,0x41u8,0x03u8,0x07u8,
            0x0du8,0x15u8,0x0fu8,0x14u8,0x53u8,0x58u8,0x5cu8,0x54u8,0x14u8,0x50u8,0x0du8,0x0bu8,0x17u8,0x4au8,
            0x45u8,0x35u8,0x02u8,0x54u8,0x11u8,0x5fu8,0x5cu8,0x58u8,0x50u8,0x12u8,0x16u8,0x0au8,0x01u8,0x45u8,
            0x12u8,0x08u8,0x42u8,0x45u8,0x5du8,0x41u8,0x14u8,0x54u8,0x02u8,0x42u8,0x00u8,0x0bu8,0x0bu8,0x15u8,
            0x02u8,0x41u8,0x44u8,0x53u8,0x47u8,0x14u8,0x46u8,0x0eu8,0x0eu8,0x0fu8,0x0du8,0x06u8,0x0fu8,0x13u8,
            0x45u8,0x55u8,0x5bu8,0x5du8,0x1au8
        ].to_vec();
        let dec = xor_crypt(input, b"abcdefg012345");
        let result = std::str::from_utf8(&dec).unwrap();
        let want = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed molestie tortor ac consequat sollicitudin.";
        assert_eq!(result, want);
    }
}