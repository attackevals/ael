package sodamaster

import (
    "bytes"
    "fmt"
    "os"
    "testing"
    "time"

    "attackevals.mitre-engenuity.org/control_server/config"
    "attackevals.mitre-engenuity.org/control_server/handlers/util"
    "attackevals.mitre-engenuity.org/control_server/restapi"
)

const (
    handlerName          = "sodamaster"
    restAPIlistenHost    = "127.0.0.1:9994"
    restAPIBaseURL       = "http://" + restAPIlistenHost + "/api/v1.0/"
    testUUID             = "test-implant-id"
    testUuidHex          = "746573742d696d706c616e742d6964"
    testComputerName     = "test-computer-name"
    testUser             = "test-user"
    testPID              = 1234
    invalidTest          = "invalid data"
    exampleBcnTask       = "{\"id\":\"b\"}"
    beaconTaskHex        = "62"
    exampleMsgBoxTask    = "{\"id\":\"w\", \"cmd\":\"Hello World!\"}"
    msgBoxTaskHex        = "7702010248656c6c6f20576f726c6421"
    exampleSleepTask     = "{\"id\":\"l\", \"cmd\":\"15\"}"
    sleepTaskHex         = "6c01023135"
    exampleExitTask      = "{\"id\":\"x\"}"
    exitTaskHex          = "78"
    exampleExecuteTask   = "{\"id\":\"s\", \"payload\":\"examplepayload.txt\", \"payloadPath\":\"C:/Windows/Temp\", \"args\":\"whoami -priv\"}"
    exampleMissingIdTask = "{\"payload\":\"examplepayload.txt\", \"payloadPath\":\"C:/Windows/Temp\", \"args\":\"whoami -priv\"}"
    exampleBadIdTask     = "{\"id\":0, \"cmd\":\"Hello World!\"}"
    identifierHex        = "534F44414D4153544552"
    helloWorldFilename   = "hello_world.pdf"
    helloWorldElfHash    = "ff1665c2e7239b61f8d3f22248a4bff8"

    // Test packet strings are generated by taking the hex conversion of the uuid or identifier, command id, length of the length, data length, and the data
    //
    // Identifier 'SODAMASTER' -> '534F44414D4153544552' + initial discovery data converted to appropriate packet format ^
    // User: 'testuser', Computer name: 'testcomputer', PID: 1234, Data executed: '2023-06-05 15:38:37', PrivilegeFlag: '0'
    sampleFirstPacket = identifierHex + "03010874657374757365720401043132333405020109323032332D30362D30352031353A33383A33370702313274657374636F6D707574657209010130"

    // Session id '496ff2c7cb4a3d1789d734a97dca8d02' -> '3439366666326337636234613364313738396437333461393764636138643032'
    // + command id '99' -> '63' + length of length 01 + data length 08 + data 'testuser' -> '7465737475736572'
    samplePacket = "34393666663263376362346133643137383964373334613937646361386430326301087465737475736572"

    // Unregistered session id  'd66bf64412f9244a336cff3d4a1805e3' -> '6436366266363434313266393234346133333663666633643461313830356533'
    // + command id '99' -> '63' + length of length 01 + data length 08 + data 'testuser' -> '7465737475736572'
    invalidPacket = "64363662663634343132663932343461333336636666336434613138303565336301087465737475736572"
)

var testRC4Key = []byte("test-rc4-key")

var exampleFirstPacketStruct = &ImplantData{
    UUID:          "",
    User:          "bobsmith",
    ComputerName:  "bobscomputer",
    PID:           18036,
    DateExec:      "2023-06-01 19:10:39",
    SocketName:    "",
    PrivilegeFlag: "0",
    Data:          "",
    DataLength:    0,
    Beacon:        true,
}

var exampleInvalidFirstPacketStruct = &ImplantData{
    UUID:          "",
    User:          "bobsmith",
    ComputerName:  "",
    PID:           18036,
    DateExec:      "2023-06-01 19:10:39",
    SocketName:    "",
    PrivilegeFlag: "0",
    Data:          "",
    DataLength:    0,
    Beacon:        true,
}

var exampleBeaconStruct = &ImplantData{
    UUID:   "test-implant-id",
    Beacon: true,
}

var exampleResponseStruct = &ImplantData{
    UUID:       "test-implant-id",
    Data:       "example task output data",
    DataLength: 24,
    Beacon:     false,
}

var exampleBcnTaskStruct = Task{
    id: "b",
}

var exampleMsgBoxTaskStruct = Task{
    id:     "w",
    cmd:    "Hello World!",
    lenCmd: 12,
}

var exampleExecuteTaskStruct = Task{
    id:          "s",
    args:        "whoami -priv",
    lenArgs:     12,
    payloadName: "examplepayload.txt",
    payloadPath: "C:/Windows/Temp",
    payloadData: []byte("example payload"),
    lenPayload:  15,
}

var configEntry = config.HandlerConfigEntry{
    "host": "127.0.0.1",
    "port": 8080,
}

func startSodaMasterHandler(handler *sodaMasterHandler, t *testing.T) {
    if err := handler.StartHandler(restAPIlistenHost, configEntry); err != nil {
        t.Errorf("Error when starting SodaMaster handler: %s", err.Error())
    }
    util.RunningHandlers[handlerName] = handler
    time.Sleep(50 * time.Millisecond)
}

func stopSodaMasterHandler(handler *sodaMasterHandler, t *testing.T) {
    if err := handler.StopHandler(); err != nil {
        t.Errorf("Error when stopping SodaMaster handler: %s", err.Error())
    }
    delete(util.RunningHandlers, handlerName)
    time.Sleep(50 * time.Millisecond)
}

func startRESTAPI(t *testing.T) {
    restapi.Start(restAPIlistenHost, "./test_payloads")
    time.Sleep(50 * time.Millisecond)
    t.Log("Started REST API server")
}

func stopRESTAPI(t *testing.T) {
    restapi.Stop()
    time.Sleep(50 * time.Millisecond)
    t.Log("Stopped REST API server")
}

func TestStartStopSodaMasterHandler(t *testing.T) {
    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)
}

func TestHasImplantSessionAndStoreImplantSession(t *testing.T) {
    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    if handler.hasImplantSession("invalid-id") {
        t.Error("Implant invalid-id should not have an active session.")
    }

    uuid := "implant1"
    err := handler.storeImplantSession(uuid)
    if err != nil {
        t.Error(err.Error())
    }
    if !handler.hasImplantSession(uuid) {
        t.Error("Expected implant session to be stored.")
    }

    err = handler.storeImplantSession(uuid)
    want := fmt.Sprintf("Session %s already exists.", uuid)
    if err != nil {
        if err.Error() != want {
            t.Errorf("Expected error message: %s; got: %s", want, err.Error())
        }
    } else {
        t.Error("Expected error message.")
    }
}

func TestCreateNewSessionDataBytes(t *testing.T) {
    want := "{\"guid\":\"test-implant-id\",\"hostName\":\"test-computer-name\",\"pid\":1234,\"user\":\"test-user\"}"
    result := string(createNewSessionDataBytes(testUUID, testComputerName, testUser, testPID))
    if result != want {
        t.Errorf("Expected %s; got: %s", want, result)
    }
}

func compareImplantData(got *ImplantData, want *ImplantData, t *testing.T) {
    if got.UUID != want.UUID {
        t.Errorf("Expected UUID %s; got: %s", want.UUID, got.UUID)
    }
    if got.User != want.User {
        t.Errorf("Expected username %s; got: %s", want.User, got.User)
    }
    if got.ComputerName != want.ComputerName {
        t.Errorf("Expected computer name %s; got: %s", want.ComputerName, got.ComputerName)
    }
    if got.PID != want.PID {
        t.Errorf("Expected PID %d; got: %d", want.PID, got.PID)
    }
    if got.DateExec != want.DateExec {
        t.Errorf("Expected date executed %s; got: %s", want.DateExec, got.DateExec)
    }
    if got.SocketName != want.SocketName {
        t.Errorf("Expected socket name %s; got: %s", want.SocketName, got.SocketName)
    }
    if got.PrivilegeFlag != want.PrivilegeFlag {
        t.Errorf("Expected privilege flag %s; got: %s", want.PrivilegeFlag, got.PrivilegeFlag)
    }
    if bytes.Compare(got.RC4Key, want.RC4Key) != 0 {
        t.Errorf("Expected RC4 key %v, got %v", want.RC4Key, got.RC4Key)
    }
    if got.Data != want.Data {
        t.Errorf("Expected data %s; got: %s", want.Data, got.Data)
    }
    if got.DataLength != want.DataLength {
        t.Errorf("Expected data length %d; got: %d", want.DataLength, got.DataLength)
    }
    if got.Beacon != want.Beacon {
        t.Errorf("Expected beacon %v, got %v", want.Beacon, got.Beacon)
    }
}

func TestParseImplantData(t *testing.T) {
    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    want := &ImplantData{
        User:          "testuser",
        ComputerName:  "testcomputer",
        PID:           1234,
        DateExec:      "2023-06-05 15:38:37",
        PrivilegeFlag: "0",
        Beacon:        true,
    }

    result, err := handler.parseImplantData(sampleFirstPacket)
    if err != nil {
        t.Error(err.Error())
    }
    compareImplantData(result, want, t)

    //test when sending packet with session ID
    want = &ImplantData{
        UUID:       "496ff2c7cb4a3d1789d734a97dca8d02",
        Data:       "testuser",
        DataLength: 8,
        Beacon:     false,
    }
    err = handler.storeImplantSession(want.UUID)

    result, err = handler.parseImplantData(samplePacket)
    if err != nil {
        t.Error(err.Error())
    }
    compareImplantData(result, want, t)

    //test when sending packet with invalid session id
    result, err = handler.parseImplantData(invalidPacket)
    if err == nil && result != nil {
        t.Errorf("Expected error, got %v", result)
    }
}

func TestRegisterNewImplant(t *testing.T) {
    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    // send register request and check that the implant gets registered
    err := handler.registerNewImplant(testUUID, testUser, testComputerName, testPID, testRC4Key)
    if err != nil {
        t.Errorf(err.Error())
    }
}

func TestUpdateImplantSession(t *testing.T) {
    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    //register implant session
    err := handler.registerNewImplant(testUUID, testUser, testComputerName, testPID, testRC4Key)
    if err != nil {
        t.Errorf(err.Error())
    }

    //update the implant session and check for success message
    updatedPID := 5678
    err = handler.updateImplantSession(testUUID, updatedPID)
    if err != nil {
        t.Errorf(err.Error())
    }
}

func TestRemoveImplant(t *testing.T) {
    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    //register new implant session
    err := handler.registerNewImplant(testUUID, testUser, testComputerName, testPID, testRC4Key)
    if err != nil {
        t.Errorf(err.Error())
    }

    //remove the implant session
    err = handler.removeImplantSession(testUUID)
    if err != nil {
        t.Errorf(err.Error())
    }
    if _, ok := handler.rc4Keys[testUUID]; ok {
        t.Errorf("Implant not successfully removed: RC4 key was not deleted.")
    }
    if _, ok := handler.commandNumbers[testUUID]; ok {
        t.Errorf("Implant not successfully removed: command numbers entry was not deleted.")
    }
    if _, ok := handler.pendingCommandOutput[testUUID]; ok {
        t.Errorf("Implant not successfully removed: pending command output entry was not deleted.")
    }
}

func TestHandleBeacon(t *testing.T) {
    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    //check output for the implant's first beacon (first packet)
    want := "653834376566376134393635623936643332376330646639636630366633313662" //hex string of the session ID and beacon id "b"
    response, err := handler.handleBeacon(*exampleFirstPacketStruct)
    if err != nil {
        t.Error(err.Error())
    }
    if want != response {
        t.Errorf("Expected %s; got: %s", want, response)
    }

    //check output for implant's first beacon w/o the proper fields (missing the computer name)
    errWant := "Implant's first packet must contain the user and computer names. Packet is not valid."
    response, err = handler.handleBeacon(*exampleInvalidFirstPacketStruct)
    if err.Error() != errWant {
        t.Errorf("Got '%s' expected '%s'", err.Error(), errWant)
    }

    //register implant session
    err = handler.registerNewImplant(testUUID, testUser, testComputerName, testPID, testRC4Key)
    if err != nil {
        t.Errorf(err.Error())
    }

    //check output for already registered implant (not the first packet) and no task
    want = testUuidHex + beaconTaskHex
    response, err = handler.handleBeacon(*exampleBeaconStruct)
    if err != nil {
        t.Error(err.Error())
    }
    if want != response {
        t.Errorf("Expected %s; got: %s", want, response)
    }

    //set a task
    _, err = setTask(exampleSleepTask, testUUID, restAPIBaseURL)
    if err != nil {
        t.Error(err.Error())
    }

    //check output for already registered implant (not the first packet) and a task
    want = testUuidHex + sleepTaskHex
    response, err = handler.handleBeacon(*exampleBeaconStruct)
    if err != nil {
        t.Error(err.Error())
    }
    if want != response {
        t.Errorf("Expected %s; got: %s", want, response)
    }
}

func TestHandleResponse(t *testing.T) {
    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    //check output for when there is no pending command output- should get an error
    errWant := "Implant test-implant-id does not have any tasks pending output."
    _, err := handler.handleResponse(*exampleResponseStruct)
    if err == nil {
        t.Errorf("Expected error and got none.")
    } else if err.Error() != errWant {
        t.Errorf("Got '%s' expected '%s'", err.Error(), errWant)
    }

    //register implant session
    err = handler.registerNewImplant(testUUID, testUser, testComputerName, testPID, testRC4Key)
    if err != nil {
        t.Errorf(err.Error())
    }

    //check output for when there is pending command output
    want := testUuidHex + beaconTaskHex
    response, err := handler.handleResponse(*exampleResponseStruct)
    if want != response {
        t.Errorf("Expected %s; got: %s", want, response)
    }
}

func compareTasks(got *Task, want *Task, t *testing.T) {
    if got.id != want.id {
        t.Errorf("Expected task ID %s, got %s", want.id, got.id)
    }
    if got.lenPayload != want.lenPayload {
        t.Errorf("Expected payload length %d, got %d", want.lenPayload, got.lenPayload)
    }
    if bytes.Compare(got.payloadData, want.payloadData) != 0 {
        t.Errorf("Expected payload data %v, got %v", want.payloadData, got.payloadData)
    }
    if got.cmd != want.cmd {
        t.Errorf("Expected commands %s, got %s", want.cmd, got.cmd)
    }
    if got.lenCmd != want.lenCmd {
        t.Errorf("Expected command length %d, got %d", want.lenCmd, got.lenCmd)
    }
    if got.args != want.args {
        t.Errorf("Expected args %s, got %s", want.args, got.args)
    }
    if got.lenArgs != want.lenArgs {
        t.Errorf("Expected args length %d, got %d", want.lenArgs, got.lenArgs)
    }
    if got.payloadPath != want.payloadPath {
        t.Errorf("Expected payload path %s, got %s", want.payloadPath, got.payloadPath)
    }
    if got.payloadName != want.payloadName {
        t.Errorf("Expected payload name %s, got %s", want.payloadName, got.payloadName)
    }
}
func TestExtractTaskParts(t *testing.T) {
    // set current working directory to main repo directory to access ./files
    cwd, _ := os.Getwd()
    os.Chdir("../../")
    defer os.Chdir(cwd) // restore cwd at end of test

    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    //check output for simple beacon task
    var task Task
    err := handler.extractTaskParts(exampleBcnTask, &task)
    if err != nil {
        t.Errorf("Got error when none expected: %s", err.Error())
    }
    compareTasks(&task, &exampleBcnTaskStruct, t)

    //check output for message box task
    var taskMsgBox Task
    err = handler.extractTaskParts(exampleMsgBoxTask, &taskMsgBox)
    if err != nil {
        t.Errorf("Got error when none expected: %s", err.Error())
    }
    compareTasks(&taskMsgBox, &exampleMsgBoxTaskStruct, t)

    //check output for execute task
    var taskExecute Task
    err = handler.extractTaskParts(exampleExecuteTask, &taskExecute)
    if err != nil {
        t.Errorf("Got error when none expected: %s", err.Error())
    }
    compareTasks(&taskExecute, &exampleExecuteTaskStruct, t)

    //check output for task with no ID
    err = handler.extractTaskParts(exampleMissingIdTask, &task)
    errWant := "Command ID not provided in task string"
    if err.Error() != errWant {
        t.Errorf("Got '%s' expected '%s'", err.Error(), errWant)
    }

    //check output for task with invalid ID type
    errWant = "Bad command ID: 0"
    err = handler.extractTaskParts(exampleBadIdTask, &task)
    if err.Error() != errWant {
        t.Errorf("Got '%s' expected '%s'", err.Error(), errWant)
    }
}

func TestConvertTaskToResponse(t *testing.T) {
    // start REST API and handler
    startRESTAPI(t)
    defer stopRESTAPI(t)

    handler := sodaMasterHandlerFactory()
    startSodaMasterHandler(handler, t)
    defer stopSodaMasterHandler(handler, t)

    // check that the function returns an error when the implant has no session
    task, err := handler.convertTaskToResponse(testUUID, exampleBcnTask)
    if task != "" {
        t.Errorf("Got '%s' expected empty string", task)
    }
    errWant := "No existing session for implant " + testUUID + "."
    if err.Error() != errWant {
        t.Errorf("Got '%s' expected '%s'", err.Error(), errWant)
    }

    //register implant session
    err = handler.registerNewImplant(testUUID, testUser, testComputerName, testPID, testRC4Key)
    if err != nil {
        t.Errorf(err.Error())
    }

    //check for correct output when there is no task
    result, _ := handler.convertTaskToResponse(testUUID, "")
    want := testUuidHex + beaconTaskHex
    if result != want {
        t.Errorf("Got '%s', expected '%s'", result, want)
    }

    //check for correct output with beacon task
    result, _ = handler.convertTaskToResponse(testUUID, exampleBcnTask)
    want = testUuidHex + beaconTaskHex
    if result != want {
        t.Errorf("Got '%s', expected '%s'", result, want)
    }

    //check for correct output with message box task
    result, _ = handler.convertTaskToResponse(testUUID, exampleMsgBoxTask)
    want = testUuidHex + msgBoxTaskHex
    if result != want {
        t.Errorf("Got '%s', expected '%s'", result, want)
    }

    //check for correct output with sleep task
    result, _ = handler.convertTaskToResponse(testUUID, exampleSleepTask)
    want = testUuidHex + sleepTaskHex
    if result != want {
        t.Errorf("Got '%s', expected '%s'", result, want)
    }

    //check for correct output with exit task
    result, _ = handler.convertTaskToResponse(testUUID, exampleExitTask)
    want = testUuidHex + exitTaskHex
    if result != want {
        t.Errorf("Got '%s', expected '%s'", result, want)
    }
}
