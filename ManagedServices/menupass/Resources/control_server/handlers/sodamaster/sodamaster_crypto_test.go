package sodamaster

import (
    "crypto/rsa"
    "crypto/x509"
    "encoding/base64"
    "testing"
)

const (
    //Commands used to generate the example RSA key pair can be found in the Encryption section of the SodaMaster README
    exampleRsaPrivKey = "MIIEowIBAAKCAQEAn8Sf4PlyGgOTB0dbZbesy3kbIpvmZa68tE5IX9ClPB0K8zKG4lm6BHiwcYGaQ8/WoY6WuGKVz6+tjOoW7JB6pPapRdo8uNdliecnkd5bJkBMUFGyWNt7E46FzxZxjr5drqaaVj8vkTzeAj3UPXRoqAD6Y0a+atbZG8MJKz9FYzwLaKfdxXOC89jAxuNZp5o7FiKmY1TmDfV+qbF1HCK4X9EIdin3xQVDTgIbyXQW1j4D2RrIHrFLyt+WlTKnBtYd2LXBEBvIcrCUurBj/Wx+6wYd1OAuxaq3Znce14cMV40eDAryy4Kslvr67Mbfhb+C3i9qNJym2G6Sb55HIs7UCQIDAQABAoIBAAbIaTqQPIjgMqNyIxjhaw5EY6OHgjOPmeapwCbZNnqj3QLQLVZ6FWH6jGXKk8sMjYHUX4+6bRPL0zln+CCDoxan0NiXWFFHS8HxX1uxA1D6FS3/xJZDKH7UY9fpOFmlZALLLe2QHIE1Aqk5CMQHJ35NHv7h/P7k2i4fN0oaaI6656zSeGcCzof+1od0Q/T1G26w6cr0HvqSz37VtSUAKWpGumGJBXzeWuvPgBtyh198VOpNP1c91bxsSvHutehsHz6vS225ROW5k9z7eMHkU2oS8tvw3Fhv//sUPwntN87w4hDboeGevo9clVzsL5vlTwiAONa2cuVMfK3MFoOq5jUCgYEAwZX4ZVKrw5/G3gQewG2JbVHnUgZSeDURfNexmznpDMOauVKagRnHsWKZDwXOnkGqN17WSKeXa95HwyZhBBZ+OYHuyrMZ59P870m09uhvQZ1nWslAKjvr4X6hZhZqRSSYYEMEHPWjMM0/pYsv3AXCnpUlYufJuG+WLNDQKK3acE8CgYEA00dufc1MSFkghz8HoqcPU5D7RwDqkwQvWzGb3qoSUEQlcRDoKICAW3cx2hpKhW39yXmbyT4CMyNV+ZC1veKhl1haYZU413scoshr2sEJ4Lxleh9+gAR8B3XoHNgnA/jF+CxsnxEZlggR8H4foQMT5oqt9R50oJfTpSwnECgWyCcCgYEAsQYNQcqZm6hOWNP3swv3sepF2DJD0/zjYwBzP3lzbeKpaHLrKseCXunFAYHT8dAmcb/dwE7RHykDAqfj67MN9lSlIuMo+2BVWhRS0b63jo775n9Gl9h32ZrMyOgSgev3E3/1EO5nLsdiPmXLfC4gTJgiuhEv2+Let1i0IZ7ps+0CgYAMCNSVW91Nfa4ppgB0Vlm8I9T8TWQPLbzYz/GV9FAIvGj5kMH4lKE7FIYFa1v1T7eWA1RJWTvc19Vs2r5Pa5pSuZikWFCdjYirCQmDs10xrOmG1EZrWlYKQsAO7I0EX+Y+5aDmSp4PerQy46w/iqJWjm2sOajhAOTwUpyDAhWSHwKBgDb/ypcloc4+OdBlJNaLDpBe7SLxHEhc9UC9jHQcMJ2aQlCQUpAJTOnG7q6O0KYSUsEdpSHTcnJlE3NM2zAFS7XSM0+rjc/eCZ52T0GwCwSLlcnAG6icu3YR+lrRzNTAIVJAhfIqZeT1E6b3PguRfFQ0iL5kqXX0083lckgCzVoD"
    exampleRsaPubKey  = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAn8Sf4PlyGgOTB0dbZbesy3kbIpvmZa68tE5IX9ClPB0K8zKG4lm6BHiwcYGaQ8/WoY6WuGKVz6+tjOoW7JB6pPapRdo8uNdliecnkd5bJkBMUFGyWNt7E46FzxZxjr5drqaaVj8vkTzeAj3UPXRoqAD6Y0a+atbZG8MJKz9FYzwLaKfdxXOC89jAxuNZp5o7FiKmY1TmDfV+qbF1HCK4X9EIdin3xQVDTgIbyXQW1j4D2RrIHrFLyt+WlTKnBtYd2LXBEBvIcrCUurBj/Wx+6wYd1OAuxaq3Znce14cMV40eDAryy4Kslvr67Mbfhb+C3i9qNJym2G6Sb55HIs7UCQIDAQAB"
)

var (
    exampleRC4Key        = []byte("818D0DFD4F08C3570CF1A6E6B91F6C9A")
    exampleRC4Keys       = map[string][]byte{"UnusedKey1": []byte("C28F4433D4120BCA628528874B3AFB3E"), "UnusedKey2": []byte("BDFC2ADB1F525192BDA16ACCBB0E91EE"), "CorrectKey": []byte("818D0DFD4F08C3570CF1A6E6B91F6C9A"), "UnusedKey3": []byte("91BC6C8F7EA59671DB9FDE3E6B10F50D")}
    exampleRC4BadKeys    = map[string][]byte{"UnusedKey1": []byte("C28F4433D4120BCA628528874B3AFB3E"), "UnusedKey2": []byte("BDFC2ADB1F525192BDA16ACCBB0E91EE"), "UnusedKey3": []byte("91BC6C8F7EA59671DB9FDE3E6B10F50D")}
    examplePlaintext     = "Hello World!"
    exampleBadCiphertext = "aW52YWxpZCBjaXBoZXJ0ZXh0" //B64 Encode("invalid ciphertext")

    //RC4 cipher text is generated by: B64 Encode(RC4 Encrypt with exampleRC4Key(B64 Encode("Hello World!")))
    exampleRC4Ciphertext = "z9fZIEAbSWM2a9s0IJL0kg=="

    //RSA cipher text is generated by: B64 Encode(RSA Encrypt with exampleRsaPubKey(B64Encode("Hello World!")))
    exampleRSACiphertext = "K70mkFqLp5ZCan+OOnXeeBKGvNwPbbJn1wQFbMqjYUZbRZSxl7MVKSvKNiDk4l91ZAddk4nV+N3ATu6Sqh82/tnRGUsQMksed/08K2ZpKDZNp5Av8Ce0h+ONhjKHc0T/Cy6Q09rbGHwKdGqiPUFPZOiEFwOtgVP2kfksVNFa9cGT6SdyCmJP0r6+71mzkLvmPZ6ru6/IWee9T2P6B6twxUrWQX7TERai2IF6AOXQ4POrABtqCW5TXyE8zR1dSLQ+cxZOXycRUS4K8rrEYEO8NpkhguC//EFo9YciyGK/qIakoZzhMM66mP9j3Tl3GEvlI9JGrX3mlDCnGuZYxmZARQ=="
)

func importPrivKey() (*rsa.PrivateKey, error) {
    keyData, err := base64.StdEncoding.DecodeString(exampleRsaPrivKey)
    if err != nil {
        return nil, err
    }
    privKey, err := x509.ParsePKCS1PrivateKey(keyData)
    if err != nil {
        return nil, err
    }
    return privKey, nil
}

func TestRC4(t *testing.T) {
    //Test RC4 Encryption
    ciphertext, err := rc4Encrypt([]byte(examplePlaintext), exampleRC4Key)
    if err != nil {
        t.Error(err.Error())
    }
    if string(ciphertext) != exampleRC4Ciphertext {
        t.Errorf("Expected: %s; got: %s", exampleRC4Ciphertext, string(ciphertext))
    }

    //Test RC4 Decryption
    plaintext, err := rc4Decrypt(exampleRC4Ciphertext, exampleRC4Key)
    if err != nil {
        t.Error(err.Error())
    }
    if plaintext != examplePlaintext {
        t.Errorf("Expected: %s; got: %s", examplePlaintext, plaintext)
    }
}

func TestDecrypt(t *testing.T) {
    //Import the RSA private key
    privKey, err := importPrivKey()
    if err != nil {
        t.Error(err.Error())
    }

    //Test RSA decryption
    result, firstPacket, err := decrypt(exampleRSACiphertext, privKey, exampleRC4Keys)
    if err != nil {
        t.Error(err.Error())
    }
    if examplePlaintext != result {
        t.Errorf("Expected: %s; got: %s", examplePlaintext, result)
    }
    if !firstPacket {
        t.Error("First packet must be true for RSA decryption.")
    }

    //Test RC4 decryption
    result, firstPacket, err = decrypt(exampleRC4Ciphertext, privKey, exampleRC4Keys)
    if err != nil {
        t.Error(err.Error())
    }
    if examplePlaintext != result {
        t.Errorf("Expected: %s; got: %s", examplePlaintext, result)
    }
    if firstPacket {
        t.Error("First packet must be false for RC4 decryption.")
    }

    //Test with invalid data
    errWant := "Decryption unsuccessful: Invalid data or no valid keys."
    result, firstPacket, err = decrypt(exampleBadCiphertext, privKey, exampleRC4Keys)
    if err == nil {
        t.Error("Expected error and got none.")
    } else if err.Error() != errWant {
        t.Errorf("Expected err: %s, got: %s", errWant, err.Error())
    }
    if firstPacket {
        t.Error("First packet must be false if RSA decryption fails.")
    }

    //Test with valid data, but no valid keys
    _, firstPacket, err = decrypt(exampleRC4Ciphertext, privKey, exampleRC4BadKeys)
    if err == nil {
        t.Error("Expected error and got none.")
    } else if err.Error() != errWant {
        t.Errorf("Expected err: %s, got: %s", errWant, err.Error())
    }
    if firstPacket {
        t.Error("First packet must be false if RSA decryption fails.")
    }
}
