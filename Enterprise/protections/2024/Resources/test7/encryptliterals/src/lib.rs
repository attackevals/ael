use proc_macro::TokenStream;
use proc_macro2::Literal;
use quote::quote;
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use syn::{parse_macro_input, LitStr};

// Random seed for XOR key
lazy_static::lazy_static! {
    static ref RAND_SEED: [u8; 64] = {
        let mut seed = [0u8; 64];
        let mut rng = ChaCha20Rng::from_entropy();
        ChaCha20Rng::fill_bytes(&mut rng, &mut seed);
        seed
    };
}

fn xor_crypt(input: Vec<u8>, key: &[u8]) -> Vec<u8> {
    let mut key_iter = key.iter().cycle();
    return input.into_iter().map(|x| x ^ key_iter.next().unwrap()).collect()
}

fn get_xor_key() -> Vec<u8> {
    // Encrypted using random key generated by /dev/urandom
    xor_crypt(RAND_SEED.to_vec(), b"c27abfd9ea8cf0c81d07b6f9ae9d2a8e")
}

/// Sets the XOR encryption key for encrypting string literals in a esl! macro. 
/// The key seed will be randomly generated each time during compilation.
/// The key seed will be XOR-encrypted to generate the actual XOR key.
/// Adapted from litcrypt crate: https://github.com/anvie/litcrypt.rs
#[proc_macro]
pub fn setup_string_literal_encryption(_input: TokenStream) -> TokenStream {
    // Grab XOR key
    let xor_key = get_xor_key();
    let enc_key_literal = Literal::byte_string(&xor_key);

    quote! {
        pub mod string_lit_encrypt {
            pub static STRING_LITERAL_ENC_KEY: &'static [u8] = #enc_key_literal;

            pub fn decrypt(input: &[u8], key: &[u8]) -> String {
                let mut key_iter = key.iter().cycle();
                let decrypted = input.into_iter().map(|x| x ^ key_iter.next().unwrap()).collect();
                match std::string::String::from_utf8(decrypted) {
                    Ok(s) => s,
                    Err(_) => String::from("[esl unknown]")
                }
            }
        }
    }.into()
}

/// Encrypt the string literal using the key from setup_string_literal_encryption, 
/// and replace with a function call to decrypt the ciphertext during runtime.
/// Adapted from litcrypt crate: https://github.com/anvie/litcrypt.rs
#[proc_macro]
pub fn esl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LitStr);
    let string_to_encrypt = input.value();
    let encrypted = xor_crypt(string_to_encrypt.into_bytes(), &get_xor_key());
    let encrypted_literal = Literal::byte_string(&encrypted);

    // Replace with decrypt routine
    quote! {
        crate::string_lit_encrypt::decrypt(#encrypted_literal, crate::string_lit_encrypt::STRING_LITERAL_ENC_KEY)
    }.into()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xor_crypt() {
        let input:Vec<u8> = [
            0x2du8,0x0du8,0x11u8,0x01u8,0x08u8,0x46u8,0x0eu8,0x40u8,0x42u8,0x47u8,0x5eu8,0x14u8,0x51u8,0x0eu8,
            0x0eu8,0x0cu8,0x16u8,0x45u8,0x15u8,0x0eu8,0x44u8,0x11u8,0x53u8,0x5eu8,0x51u8,0x41u8,0x4du8,0x42u8,
            0x00u8,0x0bu8,0x0bu8,0x15u8,0x02u8,0x53u8,0x45u8,0x57u8,0x47u8,0x41u8,0x47u8,0x41u8,0x03u8,0x07u8,
            0x0du8,0x15u8,0x0fu8,0x14u8,0x53u8,0x58u8,0x5cu8,0x54u8,0x14u8,0x50u8,0x0du8,0x0bu8,0x17u8,0x4au8,
            0x45u8,0x35u8,0x02u8,0x54u8,0x11u8,0x5fu8,0x5cu8,0x58u8,0x50u8,0x12u8,0x16u8,0x0au8,0x01u8,0x45u8,
            0x12u8,0x08u8,0x42u8,0x45u8,0x5du8,0x41u8,0x14u8,0x54u8,0x02u8,0x42u8,0x00u8,0x0bu8,0x0bu8,0x15u8,
            0x02u8,0x41u8,0x44u8,0x53u8,0x47u8,0x14u8,0x46u8,0x0eu8,0x0eu8,0x0fu8,0x0du8,0x06u8,0x0fu8,0x13u8,
            0x45u8,0x55u8,0x5bu8,0x5du8,0x1au8
        ].to_vec();
        let dec = xor_crypt(input, b"abcdefg012345");
        let result = std::str::from_utf8(&dec).unwrap();
        let want = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed molestie tortor ac consequat sollicitudin.";
        assert_eq!(result, want);
    }
}
