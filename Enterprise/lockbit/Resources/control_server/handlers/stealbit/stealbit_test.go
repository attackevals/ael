package stealbit

import (
    "net/http"
    "os"
    "testing"

    "attackevals.mitre-engenuity.org/control_server/config"
    "attackevals.mitre-engenuity.org/control_server/handlers/handler_util"
    "attackevals.mitre-engenuity.org/control_server/restapi/restapi_test_util"
    "attackevals.mitre-engenuity.org/control_server/util/test_util"
    "attackevals.mitre-engenuity.org/control_server/util/test_util/assert_util"
)

const (
    REST_API_LISTEN_HOST = "127.0.0.1:10005"
    HEARTBEAT_URL        = "http://127.0.0.1:10016/bs/portal"
    EXFIL_URL            = "http://127.0.0.1:10016/testhash"
    EXFIL_URL2           = "http://127.0.0.1:10016/testhash2"
)

var testConfigEntry = config.HandlerConfigEntry{
    "host": "127.0.0.1",
    "port": 10016,
}

// Generate example handler using the mock function wrappers
func generateMockStealbitHandler() *StealbitHandler {
    mockFuncHandles := &WrappedFuncHandles{
        randStringGetter: handler_util.MockGetRandomAlphanumericString,
    }
    return StealbitHandlerFactory(mockFuncHandles)
}

// Starts the RestAPI, generates the handler, and returns teardown function
func setupTest(t *testing.T) (*StealbitHandler, func(t *testing.T)) {
    // Set up REST API server
    restapi_test_util.StartRestApiServer(t, "", REST_API_LISTEN_HOST, nil)

    // create and start mock handler
    handler := generateMockStealbitHandler()
    test_util.StartHandlerForUnitTest(t, handler, REST_API_LISTEN_HOST, testConfigEntry)

    return handler, func(t *testing.T) {
        restapi_test_util.StopRestApiServer()
        test_util.StopHandlerForUnitTest(t, handler)
    }
}

func cleanupTestDir(t *testing.T, dir string) {
    if err := os.RemoveAll(dir); err != nil {
        t.Error(err)
    }
}

// Test heartbeat
func TestHandleHeartbeat(t *testing.T) {
    _, teardownTest := setupTest(t)
    defer teardownTest(t)

    // Check heartbeat response
    test_util.SendGetAndCheckResponse(t, HEARTBEAT_URL, nil, HEARTBEAT_RESPONSE, http.StatusOK)
}

func TestBuildExfilChunkInfoFailure(t *testing.T) {
    var chunkInfo ExfilChunkInfo

    // Check with nil data
    err := buildExfilChunkInfo(nil, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request info size of 0 does not meet minimum length requirement.", "")

    // Check with empty data
    var data []byte
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request info size of 0 does not meet minimum length requirement.", "")

    // Check data too small
    data = []byte{0, 0, 0, 4, 65, 65, 65, 65}
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request info size of 8 does not meet minimum length requirement.", "")

    // Check config string out of bounds
    data = []byte{0, 0, 0, 20, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65}
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request config string goes out of bounds.", "")

    // Check no domain length
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, // incomplete domain length
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request data does not contain domain length.", "")

    // Check domain string out of bounds
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e,
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44, // QUITELONGTESTID
        0x00, 0x00, 0x00, 0x01, // domain length 1
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request domain string goes out of bounds.", "")

    // Check no hostname length
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, // incomplete hostname length
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request data does not contain hostname length.", "")

    // Check hostname string out of bounds
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x02, // hostname length 2
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request hostname string goes out of bounds.", "")

    // Check no filepath length
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, // incomplete filepath length
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request data does not contain file path length.", "")

    // Check filepath out of bounds
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, 0x00, 0x00, 0x04, // filepath length 4
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request file path string goes out of bounds.", "")

    // Check no content length
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, 0x00, 0x00, 0x1d, // filepath length 29
        0x43, 0x3a, 0x5c, 0x5c, 0x55, 0x73, 0x65, 0x72, // C:\\Users\Public\testfile.txt
        0x73, 0x5c, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
        0x5c, 0x74, 0x65, 0x73, 0x74, 0x66, 0x69, 0x6c,
        0x65, 0x2e, 0x74, 0x78, 0x74,
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request data does not contain file content length.", "")

    // Check content length out of bounds
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, 0x00, 0x00, 0x1d, // filepath length 29
        0x43, 0x3a, 0x5c, 0x5c, 0x55, 0x73, 0x65, 0x72, // C:\\Users\Public\testfile.txt
        0x73, 0x5c, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
        0x5c, 0x74, 0x65, 0x73, 0x74, 0x66, 0x69, 0x6c,
        0x65, 0x2e, 0x74, 0x78, 0x74,
        0x00, 0x00, 0x00, 0x10,
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Exfil chunk request content goes out of bounds.", "")

    // Check content length mismatch
    data = []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, 0x00, 0x00, 0x1d, // filepath length 29
        0x43, 0x3a, 0x5c, 0x5c, 0x55, 0x73, 0x65, 0x72, // C:\\Users\Public\testfile.txt
        0x73, 0x5c, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
        0x5c, 0x74, 0x65, 0x73, 0x74, 0x66, 0x69, 0x6c,
        0x65, 0x2e, 0x74, 0x78, 0x74,
        0x00, 0x00, 0x00, 0x02,
        0x01, 0x02, 0x03, 0x04,
    }
    err = buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertNe(t, err, nil, "")
    assert_util.AssertEq(t, err.Error(), "Expected chunk content size of 2, parsed 4.", "")
}

func TestBuildExfilChunkInfo(t *testing.T) {
    var chunkInfo ExfilChunkInfo
    data := []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, 0x00, 0x00, 0x1d, // filepath length 29
        0x43, 0x3a, 0x5c, 0x5c, 0x55, 0x73, 0x65, 0x72, // C:\\Users\Public\testfile.txt
        0x73, 0x5c, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
        0x5c, 0x74, 0x65, 0x73, 0x74, 0x66, 0x69, 0x6c,
        0x65, 0x2e, 0x74, 0x78, 0x74,
        0x00, 0x00, 0x00, 0x10,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // data
        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    }
    wantData := []byte{
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    }
    err := buildExfilChunkInfo(data, &chunkInfo)
    assert_util.AssertEq(t, err, nil, "")
    assert_util.AssertEq(t, chunkInfo.implantID, "QUITELONGTESTID", "")
    assert_util.AssertEq(t, chunkInfo.domain, "MYDOMAIN", "")
    assert_util.AssertEq(t, chunkInfo.hostname, "HOSTNAME", "")
    assert_util.AssertEq(t, chunkInfo.fileAbsPath, "C:\\\\Users\\Public\\testfile.txt", "")
    assert_util.AssertEq(t, chunkInfo.chunkLen, 16, "")
    assert_util.AssertDeepEq(t, chunkInfo.chunkData, wantData, "")
    assert_util.AssertEq(t, chunkInfo.destDir, "QUITELONGTESTID-MYDOMAIN-HOSTNAME", "")
    assert_util.AssertEq(t, chunkInfo.destFileName, "C___Users_Public_testfile.txt", "")
}

func TestExfilRequest(t *testing.T) {
    _, teardownTest := setupTest(t)
    defer teardownTest(t)

    data := []byte{
        0x00, 0x00, 0x00, 0x0f, // ID length 15
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x08, // hostname length 8
        0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, // HOSTNAME
        0x00, 0x00, 0x00, 0x1d, // filepath length 29
        0x43, 0x3a, 0x5c, 0x5c, 0x55, 0x73, 0x65, 0x72, // C:\\Users\Public\testfile.txt
        0x73, 0x5c, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
        0x5c, 0x74, 0x65, 0x73, 0x74, 0x66, 0x69, 0x6c,
        0x65, 0x2e, 0x74, 0x78, 0x74,
        0x00, 0x00, 0x00, 0x10,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // data
        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    }
    data2 := []byte{
        0x00, 0x00, 0x00, 0x10, // ID length 16
        0x51, 0x55, 0x49, 0x54, 0x45, 0x4c, 0x4f, 0x4e, // QUITELONGTESTID2
        0x47, 0x54, 0x45, 0x53, 0x54, 0x49, 0x44, 0x32,
        0x00, 0x00, 0x00, 0x08, // domain length 8
        0x4d, 0x59, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, // MYDOMAIN
        0x00, 0x00, 0x00, 0x05, // hostname length 5
        0x48, 0x4f, 0x53, 0x54, 0x32, // HOST2
        0x00, 0x00, 0x00, 0x1e, // filepath length 30
        0x43, 0x3a, 0x5c, 0x5c, 0x55, 0x73, 0x65, 0x72, // C:\\Users\Public\testfile2.txt
        0x73, 0x5c, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
        0x5c, 0x74, 0x65, 0x73, 0x74, 0x66, 0x69, 0x6c,
        0x65, 0x32, 0x2e, 0x74, 0x78, 0x74,
        0x00, 0x00, 0x00, 0x18,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // data
        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
    }

    defer cleanupTestDir(t, "../../files/QUITELONGTESTID-MYDOMAIN-HOSTNAME")
    defer cleanupTestDir(t, "../../files/QUITELONGTESTID2-MYDOMAIN-HOST2")

    // send exfil requests
    for i := 0; i < 4; i++ {
        test_util.SendPutAndCheckResponse(t, EXFIL_URL, "", nil, data, "Ok", http.StatusOK)
        test_util.SendPutAndCheckResponse(t, EXFIL_URL2, "", nil, data2, "Ok", http.StatusOK)
    }

    // Check uploaded file hashes
    dest1 := "QUITELONGTESTID-MYDOMAIN-HOSTNAME/C___Users_Public_testfile.txt"
    dest2 := "QUITELONGTESTID2-MYDOMAIN-HOST2/C___Users_Public_testfile2.txt"
    wantHash1 := "b1ccbb9831d2e3740c306a5738b064d7"
    wantHash2 := "8811678ed7853cf9758cbbad04d7c0a8"
    test_util.CheckUploadedFileHash(t, dest1, wantHash1)
    test_util.CheckUploadedFileHash(t, dest2, wantHash2)
}
