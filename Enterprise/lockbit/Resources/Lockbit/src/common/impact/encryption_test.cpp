#include "impact.hpp"
#include <filesystem>
#include <fstream>
#include <gtest/gtest.h>

class FileEncryptionTest : public ::testing::Test {
protected:
    std::wstring target_file = std::filesystem::current_path().wstring() + L"\\lockbit_enc_testfile.doc";
    std::vector<unsigned char> dummy_key;
    std::vector<unsigned char> dummy_priv_key;

    // c4e063de8ec7f5456d40d3d8c720cc2d328bd16d39730556d5659db81fc7f82619976dca0e68d0748297522273cca3e8ceb6e8f9f1ae2b41e9544093c58385094aec07506c664cbca1330c0a7637adaa89843b50e688177972534ed2c0a941f18774c12a
    unsigned char plaintext[100] = {
        0xc4, 0xe0, 0x63, 0xde, 0x8e, 0xc7, 0xf5, 0x45, 
        0x6d, 0x40, 0xd3, 0xd8, 0xc7, 0x20, 0xcc, 0x2d, 
        0x32, 0x8b, 0xd1, 0x6d, 0x39, 0x73, 0x05, 0x56, 
        0xd5, 0x65, 0x9d, 0xb8, 0x1f, 0xc7, 0xf8, 0x26, 
        0x19, 0x97, 0x6d, 0xca, 0x0e, 0x68, 0xd0, 0x74, 
        0x82, 0x97, 0x52, 0x22, 0x73, 0xcc, 0xa3, 0xe8, 
        0xce, 0xb6, 0xe8, 0xf9, 0xf1, 0xae, 0x2b, 0x41, 
        0xe9, 0x54, 0x40, 0x93, 0xc5, 0x83, 0x85, 0x09, 
        0x4a, 0xec, 0x07, 0x50, 0x6c, 0x66, 0x4c, 0xbc, 
        0xa1, 0x33, 0x0c, 0x0a, 0x76, 0x37, 0xad, 0xaa, 
        0x89, 0x84, 0x3b, 0x50, 0xe6, 0x88, 0x17, 0x79, 
        0x72, 0x53, 0x4e, 0xd2, 0xc0, 0xa9, 0x41, 0xf1, 
        0x87, 0x74, 0xc1, 0x2a
    };

    // a5605bd154696a940227f93b65e08188be443ce309325c96f600f83b96e877d5
    uint8_t key[AES_KEYLEN] = { 
        0xa5, 0x60, 0x5b, 0xd1, 0x54, 0x69, 0x6a, 0x94, 
        0x02, 0x27, 0xf9, 0x3b, 0x65, 0xe0, 0x81, 0x88, 
        0xbe, 0x44, 0x3c, 0xe3, 0x09, 0x32, 0x5c, 0x96, 
        0xf6, 0x00, 0xf8, 0x3b, 0x96, 0xe8, 0x77, 0xd5
    };

    // 54e09086167ee341c55b85a962b9f049
    uint8_t iv[AES_BLOCKLEN] = {
        0x54, 0xe0, 0x90, 0x86, 0x16, 0x7e, 0xe3, 0x41,
        0xc5, 0x5b, 0x85, 0xa9, 0x62, 0xb9, 0xf0, 0x49
    };

    virtual void SetUp() {
        std::ofstream fs_out;
        fs_out.open(target_file, std::ios::binary);
        ASSERT_TRUE(fs_out.is_open());
        fs_out.write((char*)plaintext, sizeof(plaintext));
        fs_out.close();
    }

    virtual void TearDown() {
        std::filesystem::remove(target_file);
    }
};

TEST_F(FileEncryptionTest, TestEntireFile) {
    ASSERT_TRUE(impact::EncryptFileLb(target_file, key, iv, 200, dummy_key, false));
    {
        std::ifstream in_file(target_file, std::ios::binary | std::ios::ate);
        std::streamsize size = in_file.tellg();
        in_file.seekg(0, std::ios::beg);

        // check file size
        EXPECT_EQ(size, 100); 

        // check file contents
        std::vector<char> buffer(size);
        unsigned char want[100] = {
            // Actual encryption removed for public release
            0xc4, 0xe0, 0x63, 0xde, 0x8e, 0xc7, 0xf5, 0x45, 
            0x6d, 0x40, 0xd3, 0xd8, 0xc7, 0x20, 0xcc, 0x2d, 
            0x32, 0x8b, 0xd1, 0x6d, 0x39, 0x73, 0x05, 0x56, 
            0xd5, 0x65, 0x9d, 0xb8, 0x1f, 0xc7, 0xf8, 0x26, 
            0x19, 0x97, 0x6d, 0xca, 0x0e, 0x68, 0xd0, 0x74, 
            0x82, 0x97, 0x52, 0x22, 0x73, 0xcc, 0xa3, 0xe8, 
            0xce, 0xb6, 0xe8, 0xf9, 0xf1, 0xae, 0x2b, 0x41, 
            0xe9, 0x54, 0x40, 0x93, 0xc5, 0x83, 0x85, 0x09, 
            0x4a, 0xec, 0x07, 0x50, 0x6c, 0x66, 0x4c, 0xbc, 
            0xa1, 0x33, 0x0c, 0x0a, 0x76, 0x37, 0xad, 0xaa, 
            0x89, 0x84, 0x3b, 0x50, 0xe6, 0x88, 0x17, 0x79, 
            0x72, 0x53, 0x4e, 0xd2, 0xc0, 0xa9, 0x41, 0xf1, 
            0x87, 0x74, 0xc1, 0x2a
        };
        ASSERT_TRUE(in_file.read(buffer.data(), size));
        ASSERT_EQ(in_file.gcount(), size);
        EXPECT_EQ(memcmp(buffer.data(), want, sizeof(want)), 0);
    }
}

TEST_F(FileEncryptionTest, TestPartialFile) {
    ASSERT_TRUE(impact::EncryptFileLb(target_file, key, iv, 16, dummy_key, false));
    {
        std::ifstream in_file(target_file, std::ios::binary | std::ios::ate);
        std::streamsize size = in_file.tellg();
        in_file.seekg(0, std::ios::beg);

        // check file size
        EXPECT_EQ(size, 100); 

        // check file contents
        std::vector<char> buffer(size);
        unsigned char want[100] = {
            // Actual encryption removed for public release
            0xc4, 0xe0, 0x63, 0xde, 0x8e, 0xc7, 0xf5, 0x45, 
            0x6d, 0x40, 0xd3, 0xd8, 0xc7, 0x20, 0xcc, 0x2d, 
            0x32, 0x8b, 0xd1, 0x6d, 0x39, 0x73, 0x05, 0x56, 
            0xd5, 0x65, 0x9d, 0xb8, 0x1f, 0xc7, 0xf8, 0x26, 
            0x19, 0x97, 0x6d, 0xca, 0x0e, 0x68, 0xd0, 0x74, 
            0x82, 0x97, 0x52, 0x22, 0x73, 0xcc, 0xa3, 0xe8, 
            0xce, 0xb6, 0xe8, 0xf9, 0xf1, 0xae, 0x2b, 0x41, 
            0xe9, 0x54, 0x40, 0x93, 0xc5, 0x83, 0x85, 0x09, 
            0x4a, 0xec, 0x07, 0x50, 0x6c, 0x66, 0x4c, 0xbc, 
            0xa1, 0x33, 0x0c, 0x0a, 0x76, 0x37, 0xad, 0xaa, 
            0x89, 0x84, 0x3b, 0x50, 0xe6, 0x88, 0x17, 0x79, 
            0x72, 0x53, 0x4e, 0xd2, 0xc0, 0xa9, 0x41, 0xf1, 
            0x87, 0x74, 0xc1, 0x2a
        };
        EXPECT_TRUE(in_file.read(buffer.data(), size));
        EXPECT_EQ(in_file.gcount(), size);
        EXPECT_EQ(memcmp(buffer.data(), want, sizeof(want)), 0);
    }
}
