#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <testing.h>
#include "EncUtils.hpp"
#include <string>

#define DATA_LEN 445
#define IV_LEN CryptoPP::CAST128::BLOCKSIZE
#define LOREM_IPSUM "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."

using ::testing::_;
using ::testing::AtLeast;
using ::testing::Return;
using ::testing::StrEq;

// Test fixture for shared data
class TestEncDec : public ::testing::Test {
protected:
    MockWinApiWrapper mock_api_wrapper;
    std::string testStringDecoded = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";
    std::string testStringEncoded = "TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLg=="; 
    unsigned char letters[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    std::string base64_priv_key = "MIIEoQIBAAKCAQEAxcvv98NsuX1Fuff9LDyV5fpp/MAbPvIYiMyoups9uhJz7v0E4MRCZQoM6w49rjmMTgsps3TJe8IR/6waEOTzevVBmma2LFd6Q+wlOnfdHFLa2YjCUyY1fvBP+7poc9U/hjf4mLs9hGih8wBUEPZtNYerA/aZM2bwpH7JjTXdQmCZ0Y7WalNn3me+Y9mEXQS16+uxXX3uEjB0zg9J+18H5dDRe40O91pLToAGKw/+s3bs9wuvLw0sArUQusC0T/msUOAawPgUDDv008w1PJblHRnDq6u1R1WD73VjDo1cGd/OfZH166JkVLiOXsrcgYL820cr1BuQuBoMthER5QUs7wIBEQKCAQAdFnYc6Ah1oXsx78NZVDQpWYgOlLi2buV9h4I5j0zXmU1IytsR/r54RT4ikScwNaOxH8JeJ8NG59V4bCHzbPahJBEtS1cGhVW+sck9TdzAZomYdf51o7ySqt6V9cQRCMWTvO/aOacqD2McNMERjaal/Vzp/p4PFqrrA5YcS6+Y0bZRa2DUwrhC4w6O6F+2TTuCeJy8QvYZ4FUc+mOh28c8pAHpvOnPUCI9LD27ksjwvkwzQCQH+8+lIebQuRqmQR/bsphPHJhmAxNiXP2BdfL/WkdkxM9VIKQQyZpjYHa48nlCTop/uu9vyydVr1gkp9OOmPth9nbjk8AAliElbD51AoGBAOJOrCsLobcz2YakqoxLeBbuTjWNnSsC/U5GdG7UMOjW3ZtBFX0TrQMpGmW3r9UH94tWHVrl7iCWsn2BspARw1xAoTYzIvCiYoR51qiFGRrlncmr6WQE+esbgRVJHS+BuDNhr7OxXlE5726OZHvOBlMxK5sFLJ47yh7L0oWdti1zAoGBAN+/ohjrHzIW7KGNAtOgTD2GaVIC5jmScOPCjc9A8Tqlyyk4P8Jh8sW4ny/eRtNGcVt3oJJ5O4dvgnGtvQige3dtgHJz332A97lWsGp6W7w74uFSiAKZFz0umWchrQVIHS9Y/2E8GbbvY63wJG+6OqStPn0BljBwyaEZdN4VoiOVAoGAXS90Ebl+0vc7c603KrWp61MRJRwxqEyGa4ZsLaKqujpbP+2fb7zOxRDswHjP7k6TG0GTneY04D4NQrzvLEOMrYQGJWBZrmD7Y7myvdxzv8f1rWTnoaeyM6Hp25aTjAg8ydzt/rJyIXI1acIpYCeoQF+KbQIhblTawWL8VSLSiy8CgYEAqxoSi4afYooAP0223hErPht9ty9kwp0pJqPV2rkw8JzmpwzldocjD6tMjgRURzXeNuMCUeQ8lL6vC6L594nH08w1DDp9ulOQQm932PQoCGoH2XtY8u2KPdhXML9mMTclYHE7wtObMYni0E45+xXwnAwCm9QJcFY/1Yvv9R+aGzUCgYBSb0kAPXlL7ZkwuTxfbvc10/93Ks8LDd5WaAb+gnTDFhqFGjNYNRsSF3S09oqfoITt0t4ufZfu4uqtDMFfCCmLA6K2J3asFSFV9A57f4NNtNivgMeoJFsWmLiW0obQRCbpQ1DY3AcgYPuiI8sTS0bobizCA3MenIWpyMlXT71VvQ==";
};

TEST_F(TestEncDec, testBasic){
    // Testing on known string (from internet encoder)
    auto decoded = decodeToString(testStringEncoded);
    EXPECT_THAT(decoded, StrEq(testStringDecoded));

    auto [decodedBytes, decodeLen] = decodeValue(testStringEncoded);
    auto testStringEncodedFromDecoded = encodeData(decodedBytes.get(), decodeLen);
    EXPECT_THAT(testStringEncoded, StrEq(testStringEncodedFromDecoded));
}

TEST_F(TestEncDec, testBasicEncode){
    for (unsigned char idx = 0; idx < sizeof(letters) && idx < 0x40; idx++){
        // idx = 1, 0x0000 0001, to 0000 01 (encoded as B)
        // to 0000 01PP 
        byte charLetter[] = {(byte)(idx<<2)};
        auto encodedData = encodeData(charLetter);
        // The target string is the item in the letter array, plus an A for the last bit of data, and two padding for the two shift. Also newline for some reason
        char currentChar = static_cast<char>(letters[idx]);
        std::string endString;
        endString.push_back(currentChar);
        endString.push_back('A');
        endString.push_back('=');
        endString.push_back('=');
        ASSERT_THAT(encodedData, StrEq(endString));
    }
}

TEST_F(TestEncDec, testBasicDecode){
    for (unsigned char idx = 0; idx < sizeof(letters) && idx < 0x40; idx++){
        // Decoding one char
        char currentChar = static_cast<char>(letters[idx]);
        std::string encodedStr;
        encodedStr.push_back(currentChar);
        encodedStr.push_back('A');
        encodedStr.push_back('=');
        encodedStr.push_back('=');
        encodedStr.push_back('\n');

        auto [outputData, outputDataSize] = decodeValue(encodedStr);
        ASSERT_EQ(outputDataSize, 1);
        ASSERT_EQ(outputData[0]>>2, idx) << "Failed at decoding " << encodedStr;
    }
}

TEST_F(TestEncDec, TestCast128EncDec) {
    std::string dummy_data_str = std::string(LOREM_IPSUM);
    std::vector<char> dummy_cast_plaintext = std::vector<char>(dummy_data_str.begin(), dummy_data_str.end());

    std::vector<char> ciphertext = cast128_enc::Cast128Encrypt(dummy_cast_plaintext, cast128_enc::kCast128Key);
    ASSERT_NE(ciphertext, dummy_cast_plaintext);
    ASSERT_EQ(cast128_enc::Cast128Decrypt(ciphertext, cast128_enc::kCast128Key), dummy_cast_plaintext);
}

TEST_F(TestEncDec, TestRsaDec) {
    // Catch all logging messages
    EXPECT_CALL(mock_api_wrapper, CurrentUtcTimeWrapper()).WillRepeatedly(Return(""));
    EXPECT_CALL(mock_api_wrapper, AppendStringWrapper(_, _)).Times(AtLeast(0));

    // Used cyberchef to create ciphertexts
    std::string want_message = "hi this is a test message to encrypt";
    std::string want_message2 = "ASNFZ4mrze8BI0VniavN7w==";
    std::string want_message3 = "PPNjVGPYynyDJZ0zxxwcLA==";

    /*
     * Original ciphertexts obtained using CyberChef
     * Keys generated using Crypto++'s GenerateRandomWithKeySize method
     * Corresponding public key (base64-encoded): TO CHANGE
     * To convert to PEM for use with cyberchef, decode the keys into files and run the following commands in a linux machine:
     * 
     * openssl rsa -RSAPublicKey_in -in rsa-public.key -inform DER -outform PEM -out public.pem -pubout
     * openssl rsa -in rsa-private.key -inform DER -outform PEM -out private.pem
    */
    std::vector<int> msg_ciphertext_int = {
       0x70,0x52,0xa3,0xf8,0x40,0x1f,0x32,0xa5,0xeb,0x32,0x61,0xa6,0xd3,0x4b,0x7c,0xff,0x8e,0x37,0xd1,0xff,0xf1,0x0e,0x6a,0xfa,0x83,0xe5,0x81,0x22,0xcc,0xbb,0xc4,0x23,0x16,0xb6,0xd7,0xf8,0x1d,0x84,0x56,0x47,0x47,0x10,0x86,0x42,0x89,0x81,0x8b,0x02,0xe2,0x95,0x1b,0x6d,0x51,0xa2,0x62,0xbd,0xf8,0x9b,0x19,0xac,0xb5,0x6a,0x96,0x33,0x3f,0x64,0xf7,0xcf,0x19,0xad,0x72,0xbe,0x58,0x94,0x63,0x2b,0x50,0xda,0x4c,0x86,0x4a,0xa4,0xbe,0xe2,0x71,0xa9,0x83,0x67,0xf9,0xb9,0x07,0x14,0x31,0xdc,0x14,0xda,0xf5,0x3e,0x6a,0x6d,0xe1,0x2c,0x79,0x17,0x2b,0x8b,0x83,0xd6,0xf7,0x8f,0x20,0x60,0x51,0x79,0xab,0x7b,0x0f,0x93,0x4c,0xef,0x9a,0x05,0xa6,0xa4,0x2a,0x06,0x21,0x1b,0x03,0x93,0x61,0x0d,0x35,0x42,0x4e,0xaa,0xd1,0x65,0x39,0xf7,0xab,0x62,0x9c,0x14,0x66,0xe5,0xb9,0x28,0x3c,0x5d,0x3b,0xf1,0xa1,0x98,0x0a,0xc5,0x0f,0x10,0x9f,0xbb,0x0e,0x93,0x6b,0xfb,0x83,0x84,0xd0,0x93,0xd8,0x4c,0xdd,0x03,0x03,0x62,0x3b,0x4d,0x92,0x3c,0xa0,0xd1,0xc0,0x7c,0xba,0x98,0xd2,0xb6,0x11,0x76,0x6b,0x12,0x99,0x0d,0x33,0x20,0x04,0x8e,0x8f,0x21,0x6a,0x77,0x1a,0xdd,0x0a,0x1d,0xa7,0xed,0x27,0x30,0x45,0x82,0x08,0x78,0x4d,0x83,0x52,0xe0,0x8f,0xb2,0x8a,0xa3,0xa6,0x4d,0x73,0x81,0xed,0x11,0xfe,0x03,0xe7,0x40,0x7e,0x43,0x10,0xdd,0xad,0xeb,0xb5,0x40,0xd6,0xf2,0x41,0x14,0x59,0x76,0xae,0x0f,0xc6,0x3a,0x02,0xd5,0xa3,0xdd,0x1d,0x70,0x2f,0x4a
    };
    std::vector<char> msg_ciphertext;
    for (int i: msg_ciphertext_int) {
        msg_ciphertext.push_back((char)i);
    }

    std::vector<int> msg_ciphertext_int2 = {
       0x27,0xec,0x57,0x92,0x28,0x66,0xb8,0x0b,0x7f,0x69,0x8c,0x59,0xc9,0xac,0xa1,0x8b,0x29,0xa0,0x1d,0x0f,0xd6,0x09,0xa7,0xf3,0x7d,0x07,0xf9,0xd4,0xbf,0x02,0xf2,0x90,0x3d,0x89,0x20,0x4f,0x1a,0x33,0x60,0xce,0x0c,0x16,0xcf,0xeb,0xcc,0x40,0xee,0x25,0x90,0x31,0x6a,0x19,0x27,0xfc,0x9d,0xe8,0x42,0xf3,0x1a,0xd4,0xcc,0xe6,0xb1,0x2b,0x28,0x95,0xf3,0x80,0x83,0x14,0x10,0xcf,0x94,0x53,0xba,0x56,0x5e,0x4a,0xcc,0xc2,0x1d,0x44,0x07,0xf6,0x47,0x56,0x92,0x48,0x9f,0x48,0xd3,0xd8,0xe4,0x67,0xa0,0xdd,0x2d,0x59,0xd9,0x78,0xa5,0x92,0x85,0x08,0x13,0x05,0x2b,0x72,0xb5,0x4c,0x7f,0x1f,0x1b,0xbf,0x61,0x59,0x49,0x3b,0x75,0x1b,0xfb,0x8a,0x13,0x4a,0x25,0xa1,0xe0,0xb0,0x06,0x6c,0xc3,0x3a,0x13,0x39,0x56,0x05,0xe3,0xce,0xc6,0xb6,0x20,0x66,0x0e,0xc2,0x01,0x3d,0xbd,0x18,0xde,0x3f,0x72,0x94,0x90,0xe1,0xb3,0x4c,0xe0,0xc0,0xf6,0x99,0xf7,0x7d,0xf8,0xa1,0xfd,0x02,0xea,0x00,0x90,0x7b,0x76,0xb0,0xdc,0xfd,0x59,0x74,0x75,0xe0,0x9f,0x9e,0xe9,0xab,0x40,0xac,0x26,0x8c,0x0d,0x82,0x92,0x15,0x8d,0x3d,0xda,0xfe,0x52,0x7f,0x8b,0xec,0x15,0xaa,0xe2,0xba,0xa9,0x0d,0xdf,0x8b,0xbf,0x7c,0xe9,0xe1,0x0f,0x1c,0x9c,0x3d,0xcb,0x3b,0x26,0x2e,0x26,0x74,0x38,0x52,0xfa,0x32,0xe1,0x06,0x82,0x1f,0x7b,0xfc,0x43,0xa2,0x3f,0x12,0x6b,0xd6,0x2c,0x16,0x6b,0x8b,0x8c,0x07,0xb0,0x45,0xd3,0xbd,0xbc,0x76,0xe1,0x7c,0xfa,0x79,0xea,0x84,0x45,0x99
    };
    std::vector<char> msg_ciphertext2;
    for (int i: msg_ciphertext_int2) {
        msg_ciphertext2.push_back((char)i);
    }

    std::vector<int> msg_ciphertext_int3 = {
       0x73,0x36,0x3d,0x6d,0x80,0x2c,0xab,0xe8,0xf4,0x06,0x06,0xac,0x12,0xb1,0x07,0xda,0x54,0x20,0x2a,0xcb,0xfe,0x8d,0x81,0x9a,0xd7,0x1e,0x49,0x95,0x13,0xbe,0x45,0x1a,0xca,0x2f,0xbe,0x35,0x24,0x02,0x6b,0xe4,0x77,0x47,0x0a,0xf2,0x32,0x69,0x5b,0x12,0x82,0xe0,0x07,0x75,0x75,0x1e,0x4d,0x0b,0x23,0x61,0xaa,0x77,0x3a,0x2e,0xc5,0x2f,0x1c,0xe3,0x32,0xc2,0xce,0x62,0x39,0x36,0xd1,0xbd,0x17,0x05,0x4e,0x71,0x89,0x9d,0x1b,0x6a,0x98,0x61,0xf1,0x57,0xda,0x9e,0xd1,0xb2,0xab,0x34,0x15,0x3b,0xb4,0x27,0x7d,0xd7,0xb6,0x63,0x08,0x23,0xab,0xa5,0xca,0xa4,0xf4,0x9f,0x5a,0x0b,0x9f,0x3f,0x39,0x2b,0x6c,0x89,0xa2,0x2c,0x94,0xd5,0xb1,0xa8,0xf7,0xf1,0xcb,0xc3,0x5d,0x95,0x1a,0xfb,0x71,0xbc,0xa9,0x65,0x2d,0x5a,0xab,0xd1,0x89,0x16,0x3e,0x72,0x22,0x82,0x2f,0x7c,0xbb,0x1b,0x19,0x72,0x4e,0x10,0x6f,0x12,0x56,0x5b,0x23,0x9a,0x7f,0x38,0x2b,0x73,0x2d,0x9d,0x4f,0xef,0x93,0x9a,0x0f,0x60,0x0d,0x74,0x95,0x9b,0x70,0xaa,0x93,0x49,0x0f,0x8a,0x66,0x85,0xf6,0x79,0x06,0xac,0xf2,0x14,0x4c,0xa4,0xa0,0xa6,0xc5,0x6b,0xf6,0xca,0xfd,0x43,0xd0,0x72,0xb4,0x5f,0x7c,0xb9,0x75,0xc8,0x26,0x0f,0x15,0x8f,0x1d,0x38,0x66,0xf0,0x91,0x2f,0x19,0x42,0x5b,0xaa,0x4a,0xc7,0x01,0x59,0xe9,0xe9,0x57,0x22,0x74,0x62,0x67,0x70,0x01,0xae,0xb7,0x30,0x57,0xd2,0xe6,0x22,0xbb,0xe3,0x17,0xf4,0xb7,0x89,0xc4,0xe6,0x94,0x53,0x1e,0x3e,0xce,0x05,0xee,0x2e
    };
    std::vector<char> msg_ciphertext3;
    for (int i: msg_ciphertext_int3) {
        msg_ciphertext3.push_back((char)i);
    }

    // Decrypt and compare
    std::vector<unsigned char> recovered = rsa_enc::RsaOaepSha1DecryptWithBase64Key(&mock_api_wrapper, msg_ciphertext, base64_priv_key);
    std::string recovered_msg(recovered.begin(), recovered.end());
    std::cout << recovered_msg << std::endl;
    std::vector<unsigned char> recovered2 = rsa_enc::RsaOaepSha1DecryptWithBase64Key(&mock_api_wrapper, msg_ciphertext2, base64_priv_key);
    std::string recovered_msg2(recovered2.begin(), recovered2.end());
    std::cout << recovered_msg2 << std::endl;
    std::vector<unsigned char> recovered3 = rsa_enc::RsaOaepSha1DecryptWithBase64Key(&mock_api_wrapper, msg_ciphertext3, base64_priv_key);
    std::string recovered_msg3(recovered3.begin(), recovered3.end());
    std::cout << recovered_msg3 << std::endl;

    ASSERT_THAT(recovered_msg, StrEq(want_message)) << "Failed to recover plaintext. Expected: " << want_message << ".\nReceived: " << recovered_msg << std::endl;
    ASSERT_THAT(recovered_msg2, StrEq(want_message2)) << "Failed to recover plaintext. Expected: " << want_message2 << ".\nReceived: " << recovered_msg2 << std::endl;
    ASSERT_THAT(recovered_msg3, StrEq(want_message3)) << "Failed to recover plaintext. Expected: " << want_message3 << ".\nReceived: " << recovered_msg3 << std::endl;
}

TEST_F(TestEncDec, TestDecryptServerTaskResp) {
    // Catch all logging messages
    EXPECT_CALL(mock_api_wrapper, CurrentUtcTimeWrapper()).WillRepeatedly(Return(""));
    EXPECT_CALL(mock_api_wrapper, AppendStringWrapper(_, _)).Times(AtLeast(0));

    // Used cyberchef to create ciphertexts
    std::vector<char> original_key = {
        (char) 0x01, (char) 0x23, (char) 0x45, (char) 0x67,
        (char) 0x89, (char) 0xab, (char) 0xcd, (char) 0xef,
        (char) 0x01, (char) 0x23, (char) 0x45, (char) 0x67,
        (char) 0x89, (char) 0xab, (char) 0xcd, (char) 0xef
    };
    LPCSTR want_msg = "lorem ipsum text";

    /*
     * Original ciphertexts obtained using CyberChef
     * Keys generated using Crypto++'s GenerateRandomWithKeySize method
     * Corresponding public key (base64-encoded): TO CHANGE
     * To convert to PEM for use with cyberchef, decode the keys into files and run the following commands in a linux machine:
     * 
     * openssl rsa -RSAPublicKey_in -in rsa-public.key -inform DER -outform PEM -out public.pem -pubout
     * openssl rsa -in rsa-private.key -inform DER -outform PEM -out private.pem
    */
    std::vector<int> key_blob_int = {
        0x64,0xab,0x40,0xbe,0x87,0x8b,0xd9,0xae,0x9b,0x45,0x42,0xf6,0x61,0x2e,0x30,0x57,0x10,0x71,0x8a,0xbc,0xfc,0xb7,0x7b,0x44,0x21,0x7d,0x28,0x13,0xa5,0x99,0xd1,0x85,0xe9,0xb0,0x72,0xea,0x12,0xc6,0xbd,0xb8,0x80,0xcf,0x28,0xc4,0x49,0x4e,0x37,0xd6,0x6d,0xa6,0x08,0xca,0xa6,0xd0,0xb3,0x1d,0xd2,0xc9,0x02,0xc4,0x43,0x84,0xf9,0x58,0x04,0xda,0xea,0x21,0xb4,0x63,0x6e,0x99,0x9d,0xbb,0xe4,0xfc,0x58,0x8e,0x8e,0x0f,0xd7,0xe5,0xcb,0x94,0x29,0xea,0xa2,0x47,0xcd,0x2e,0xd7,0x04,0x49,0xb8,0x6f,0x47,0x37,0xba,0x45,0xfc,0xfa,0x40,0xc8,0xc1,0x9a,0x33,0xa3,0x6a,0x78,0x60,0xbb,0xde,0xe9,0xb8,0x47,0xfe,0x16,0x83,0x78,0x89,0x9a,0x77,0x73,0xbe,0xf6,0x41,0x4c,0x5d,0xc0,0xd6,0xc9,0xb4,0x9e,0x86,0xa0,0x6a,0xba,0x3f,0x58,0xc5,0x58,0x85,0x4f,0xd0,0xb8,0x22,0xef,0x6f,0xbe,0xfb,0x40,0xc5,0xb2,0x98,0xb4,0xd8,0x11,0x99,0x39,0x47,0x38,0xe3,0x14,0x94,0xfc,0x95,0x67,0x5f,0xf9,0xbc,0x31,0x43,0xd3,0x98,0x7d,0xea,0xe3,0x46,0x4e,0xb4,0x92,0x8f,0x1b,0x9a,0xee,0x44,0x8c,0xbd,0xca,0xe9,0xf6,0x26,0xba,0x7d,0xe4,0xee,0x5b,0x68,0xa1,0xdc,0x5d,0x49,0x5f,0x64,0xe1,0x34,0x62,0x38,0x46,0x1e,0xed,0x17,0x79,0x11,0x76,0x4b,0x5f,0xec,0x91,0xe8,0xeb,0x77,0xab,0xfa,0x0f,0x08,0xf8,0xee,0x2a,0x0d,0xf3,0xd1,0x55,0x7f,0xd6,0x84,0x61,0xaa,0xa1,0xbb,0x48,0x60,0x10,0x43,0xb9,0x6e,0x4d,0x9a,0xf6,0x4b,0x59,0xeb,0x76,0x20,0x8f,0xdb
    };
    std::vector<char> ciphertext;
    for (int i: key_blob_int) {
        ciphertext.push_back((char)i);
    }
    std::vector<int> cast_ciphertext_int = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xd9, 0xaf, 0x14, 0x33, 0xce, 0xd4, 0x9f, 0x20, 0x8c, 0x02, 0x47, 0x5c, 0xd3, 0x11, 0x1e, 0xeb, 0xc8, 0xe2, 0x10, 0x0a, 0xa4, 0x75, 0x46, 0xd0
    };
    for (int i: cast_ciphertext_int) {
        ciphertext.push_back((char)i);
    }
    std::shared_ptr<byte[]> encrypted_blob = std::make_shared<byte[]>(ciphertext.size());
    std::copy(ciphertext.begin(), ciphertext.end(), encrypted_blob.get());
    
    // Decrypt and compare
    rsa_enc::rsa_private_key_base64 = std::string(base64_priv_key);
    auto [ decrypted, decrypted_len ] = DecryptServerTaskResp(&mock_api_wrapper, encrypted_blob, ciphertext.size());

    ASSERT_EQ(decrypted_len, strlen(want_msg));
    ASSERT_EQ(memcmp(want_msg, decrypted.get(), decrypted_len), 0) << "Failed to recover plaintext";
}